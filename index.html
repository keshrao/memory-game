<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .mode-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
        }

        .mode-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .mode-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .theme-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
        }

        .theme-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .theme-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .size-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
            margin-left: 10px;
        }

        .size-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .size-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .stats {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: inline-block;
        }

        .stats span {
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 15px;
        }

        .turn-indicator {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 10px 25px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: inline-block;
            min-width: 180px;
        }

        .turn-indicator span {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
        }

        .game-board {
            display: grid;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
        }

        .card {
            aspect-ratio: 1;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.matched {
            opacity: 0;
            pointer-events: none;
            transform: scale(0);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .card.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            font-size: 3em;
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .card-front {
            background: white;
            transform: rotateY(180deg);
        }

        .restart-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin: 5px;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .restart-btn:active {
            transform: translateY(0);
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
            z-index: 1000;
            max-width: 90%;
        }

        .modal.show {
            display: block;
            animation: popup 0.5s ease;
        }

        @keyframes popup {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .modal h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .modal p {
            color: #666;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .modal input {
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
            text-align: center;
            text-transform: uppercase;
        }

        .room-code {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 2em;
            color: #667eea;
            font-weight: bold;
            letter-spacing: 3px;
        }

        .score-text {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 1em;
            color: #333;
            white-space: pre-line;
            text-align: left;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .copy-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .copy-btn.copied {
            background: #4CAF50;
        }
        
        /* === In-Game Chat (Vs Friend) === */
        .chat-toggle {
          position: fixed;
          bottom: 18px;
          right: 20px;
          background: #333;
          color: #fff;
          width: 44px;
          height: 44px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 22px;
          cursor: pointer;
          box-shadow: 0 2px 6px rgba(0,0,0,0.4);
          transition: transform 0.2s ease, background 0.3s ease;
          z-index: 50;
        }
        .chat-toggle:hover { background: #444; transform: scale(1.05); }
        .chat-toggle.notify::after {
          content: "";
          position: absolute;
          top: 8px;
          right: 8px;
          width: 10px;
          height: 10px;
          background: #e74c3c;
          border-radius: 50%;
        }
        .chat-window {
          position: fixed;
          bottom: 70px;
          right: 20px;
          width: 260px;
          max-height: 330px;
          display: flex;
          flex-direction: column;
          background: #222;
          border-radius: 10px;
          box-shadow: 0 0 8px rgba(0,0,0,0.5);
          overflow: hidden;
          z-index: 50;
        }
        .chat-window.hidden { display: none; }
        #chat-header {
          background: #333;
          color: #fff;
          padding: 6px 10px;
          font-weight: 600;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .chat-close { cursor: pointer; opacity: 0.7; }
        .chat-close:hover { opacity: 1; }
        #chat-messages {
          flex: 1;
          overflow-y: auto;
          padding: 8px;
          font-size: 14px;
        }
        .message {
          margin-bottom: 4px;
          line-height: 1.3;
          word-wrap: break-word;
        }
        .message.me { text-align: right; color: #8ecaff; }
        .message.them { text-align: left; color: #ccc; }
        #chat-input-row {
          display: flex;
          border-top: 1px solid #444;
        }
        #chat-input {
          flex: 1;
          border: none;
          background: #111;
          color: #eee;
          padding: 6px;
          font-size: 14px;
        }
        #chat-send {
          background: #555;
          border: none;
          color: #fff;
          padding: 6px 10px;
          cursor: pointer;
        }
        #chat-send:hover { background: #666; }

        @media (max-width: 600px) {
            .game-board {
                gap: 5px;
                padding: 10px;
            }

            .card-face {
                font-size: 2em;
            }

            h1 {
                font-size: 2em;
            }

            .modal {
                padding: 30px 40px;
            }

            .modal h2 {
                font-size: 2em;
            }

            .modal p {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Memory Game</h1>
        
        <div class="mode-selector">
            <label for="modeSelect">Game Mode:</label>
            <select id="modeSelect" onchange="handleModeChange()">
                <option value="solo">Solo</option>
                <option value="vs-easy">VS Easy Computer</option>
                <option value="vs-medium">VS Medium Computer</option>
                <option value="vs-hard">VS Hard Computer</option>
                <option value="vs-friend">VS Friend Online</option>
            </select>
        </div>

        <div class="theme-selector">
            <label for="themeSelect">Theme:</label>
            <select id="themeSelect" onchange="handleSettingsChange()">
                <option value="fruits">üçé Fruits</option>
                <option value="dinosaurs">ü¶ï Dinosaurs</option>
                <option value="trucks">üöö Trucks</option>
                <option value="space">üöÄ Space</option>
                <option value="faces">üòÄ Faces</option>
            </select>
        </div>

        <div class="size-selector">
            <label for="sizeSelect">Grid Size:</label>
            <select id="sizeSelect" onchange="handleSettingsChange()">
                <option value="3x4">3x4</option>
                <option value="4x4">4x4</option>
                <option value="4x5">4x5</option>
                <option value="5x6">5x6</option>
                <option value="6x6">6x6</option>
            </select>
        </div>

        <div class="turn-indicator" id="turnIndicator" style="display: none;">
            <span id="turnText">Your Turn</span>
        </div>

        <div class="stats" id="stats">
            <span id="soloStats">
                <span>Moves: <span id="moves">0</span></span>
                <span>Time: <span id="timer">0:00</span></span>
            </span>
            <span id="vsStats" style="display: none;">
                <span>You: <span id="playerScore">0</span></span>
                <span>Opponent: <span id="opponentScore">0</span></span>
            </span>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <button class="restart-btn" onclick="initGame()">New Game</button>
    </div>

    <!-- Room Selection Modal -->
    <div class="modal" id="roomModal">
        <h2>Play Online</h2>
        <p>Choose an option to play with a friend:</p>
        <div class="button-group">
            <button class="restart-btn" onclick="createRoom()">Create Game</button>
            <button class="restart-btn" onclick="showJoinInput()">Join Game</button>
        </div>
        <div id="joinInput" style="display: none; margin-top: 20px;">
            <input type="text" id="roomCodeInput" placeholder="Enter Room Code" maxlength="20">
            <div class="button-group">
                <button class="restart-btn" onclick="joinRoom()">Join</button>
                <button class="restart-btn" onclick="hideJoinInput()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Waiting Modal -->
    <div class="modal" id="waitingModal">
        <h2>Waiting for Friend...</h2>
        <p>Share this code with your friend:</p>
        <div class="room-code" id="roomCodeDisplay"></div>
        <div class="button-group">
            <button class="copy-btn" onclick="copyRoomCode()">Copy Code</button>
            <button class="restart-btn" onclick="cancelRoom()">Cancel</button>
        </div>
    </div>

    <!-- Win Message Modal -->
    <div class="modal" id="winMessage">
        <h2 id="winTitle">Congratulations!</h2>
        <div id="winContent"></div>
        <div class="score-text" id="scoreText"></div>
        <div class="button-group">
            <button class="copy-btn" id="copyBtn" onclick="copyScore()">Copy Score</button>
            <button class="restart-btn" onclick="initGame()">Play Again</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove, get, push } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";


        const firebaseConfig = {
            apiKey: "AIzaSyBp8iDGPfzH84iGw0WGmDSp0QJfwTpTDdU",
            authDomain: "memory-game-21ee5.firebaseapp.com",
            databaseURL: "https://memory-game-21ee5-default-rtdb.firebaseio.com",
            projectId: "memory-game-21ee5",
            storageBucket: "memory-game-21ee5.appspot.com",
            messagingSenderId: "616933567051",
            appId: "1:616933567051:web:b1f215ae7dced7270bbbce"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Make Firebase functions available globally
        window.firebaseDb = database;
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseOnValue = onValue;
        window.firebaseUpdate = update;
        window.firebaseRemove = remove;
        window.firebaseGet = get;
        window.firebasePush = push;

        const themes = {
            fruits: ['üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'üçí', 'üçë', 'ü•ù', 'üçâ', 'üçç', 'ü•≠', 'üçê', 'ü••', 'üçã', 'ü´ê', 'üçà', 'ü•ë', 'üçÖ'],
            dinosaurs: ['ü¶ï', 'ü¶ñ', 'ü¶¥', 'ü¶é', 'üêä', 'üê¢', 'ü¶è', 'ü¶ò', 'üêâ', 'ü¶§', 'üê≤', 'ü¶í', 'üêç', 'ü¶é', 'üê∏', 'ü¶Ç', 'üï∑Ô∏è', 'ü¶ó'],
            trucks: ['üöö', 'üöõ', 'üöú', 'üöó', 'üöô', 'üöï', 'üöê', 'üöí', 'üöì', 'üöë', 'üèéÔ∏è', 'üöå', 'üöé', 'üèçÔ∏è', 'üõµ', 'üö≤', 'üõ¥', 'üöÇ'],
            space: ['üöÄ', 'üõ∏', 'üåü', '‚≠ê', 'üåô', 'ü™ê', 'üåç', 'üëΩ', 'üõ∞Ô∏è', '‚òÑÔ∏è', 'üåå', 'üî≠', 'üå†', 'üåï', 'üåé', 'üåè', '‚òÄÔ∏è', '‚ú®'],
            faces: ['üòÄ', 'ü•∞', 'üòè', 'üò≠', 'üò°', 'ü§¢', 'üò±', 'ü•≥', 'ü§Ø', 'üò¥', 'ü§ì', 'ü§ó', 'üòµ', 'ü§ê', 'ü•∫', 'ü§™', 'üòá', 'ü§§']
        };

        const gridSizes = {
            '3x4': { rows: 4, cols: 3, pairs: 6 },
            '4x4': { rows: 4, cols: 4, pairs: 8 },
            '4x5': { rows: 5, cols: 4, pairs: 10 },
            '5x6': { rows: 6, cols: 5, pairs: 15 },
            '6x6': { rows: 6, cols: 6, pairs: 18 }
        };
        
        let cards = [];
        let flippedCards = [];
        let moves = 0;
        let totalPairs = 0;
        let canFlip = true;
        let gameMode = 'solo';
        let currentPlayer = 'human';
        let playerMatches = 0;
        let opponentMatches = 0;
        let computerMemory = {};
        let computerMemoryTurns = {};
        let turnNumber = 0;
        let difficulty = 'medium';
        let startTime = null;
        let timerInterval = null;
        let finalScoreText = '';

        // Online multiplayer state
        let onlineMode = false;
        let currentRoomCode = null;
        let playerId = null;
        let playerRole = null; // 'player1' or 'player2'
        let roomListener = null;
        let previouslyMatchedCards = [];
        let lastProcessedMove = null;
        
        // === CHAT FEATURE (Vs Friend only) ===
        let chatToggle, chatWindow, chatClose, chatMessages, chatInput, chatSend;
        let unreadCount = 0;
        let chatListenerAttached = false;
        
        // Initialize chat elements immediately (module scripts run after DOM loads)
        chatToggle = document.getElementById('chat-toggle');
        chatWindow = document.getElementById('chat-window');
        chatClose = document.getElementById('chat-close');
        chatMessages = document.getElementById('chat-messages');
        chatInput = document.getElementById('chat-input');
        chatSend = document.getElementById('chat-send');
        
        if (chatToggle && chatWindow && chatClose && chatInput && chatSend) {
            chatToggle.onclick = () => {
              chatWindow.classList.toggle('hidden');
              if (!chatWindow.classList.contains('hidden')) {
                unreadCount = 0;
                chatToggle.classList.remove('notify');
                if (chatMessages) chatMessages.scrollTop = chatMessages.scrollHeight;
              }
            };
            chatClose.onclick = () => chatWindow.classList.add('hidden');
            chatSend.onclick = sendChatMessage;
            chatInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendChatMessage(); });
        }
        
        function sendChatMessage() {
          if (!chatInput) return;
          const text = chatInput.value.trim();
          if (!text || !currentRoomCode) return;
          const chatRef = window.firebaseRef(window.firebaseDb, `rooms/${currentRoomCode}/chat`);
          window.firebasePush(chatRef, {
            player: playerRole,
            text,
            time: Date.now()
          });
          chatInput.value = '';
        }
        
        // Initialize listener once per room
        function initChatListener(roomCode) {
          if (chatListenerAttached || !chatToggle) return;
          chatListenerAttached = true;
          chatToggle.classList.remove('hidden');
          const chatRef = window.firebaseRef(window.firebaseDb, `rooms/${roomCode}/chat`);
          window.firebaseOnValue(chatRef, snapshot => {
            if (!chatMessages) return;
            const data = snapshot.val();
            chatMessages.innerHTML = '';
            if (data) {
              const msgs = Object.values(data).sort((a,b) => a.time - b.time);
              msgs.forEach(msg => {
                const div = document.createElement('div');
                div.classList.add('message');
                div.classList.add(msg.player === playerRole ? 'me' : 'them');
                div.textContent = msg.text;
                chatMessages.appendChild(div);
              });
              chatMessages.scrollTop = chatMessages.scrollHeight;
              const last = msgs[msgs.length - 1];
              if (chatWindow.classList.contains('hidden') && last.player !== playerRole) {
                unreadCount++;
                chatToggle.classList.add('notify');
              }
            }
          });
        }
        
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function generateRoomCode() {
            const adjectives = ['BLUE', 'RED', 'GREEN', 'GOLD', 'PINK', 'COOL', 'FAST', 'BOLD'];
            const nouns = ['TIGER', 'EAGLE', 'SHARK', 'WOLF', 'BEAR', 'LION', 'HAWK', 'DRAGON'];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            return `${adj}-${noun}`;
        }

        window.handleModeChange = function() {
            const mode = document.getElementById('modeSelect').value;
            if (mode === 'vs-friend') {
                document.getElementById('roomModal').classList.add('show');
            } else {
                onlineMode = false;
                if (currentRoomCode && roomListener) {
                    roomListener();
                    currentRoomCode = null;
                }
                // Hide chat when switching away from vs-friend mode
                if (chatToggle) chatToggle.classList.add('hidden');
                if (chatWindow) chatWindow.classList.add('hidden');
                initGame();
            }
        };

        window.handleSettingsChange = function() {
            if (!onlineMode) {
                initGame();
            }
        };

        window.createRoom = async function() {
            playerId = generatePlayerId();
            currentRoomCode = generateRoomCode();
            playerRole = 'player1';

            const gridSize = document.getElementById('sizeSelect').value;
            const theme = document.getElementById('themeSelect').value;
            const symbols = themes[theme];
            const size = gridSizes[gridSize];
            
            const cardSymbols = [];
            for (let i = 0; i < size.pairs; i++) {
                cardSymbols.push(symbols[i], symbols[i]);
            }
            const shuffledCards = shuffle(cardSymbols);

            const roomData = {
                player1: playerId,
                player2: null,
                gridSize: gridSize,
                theme: theme,
                cards: shuffledCards,
                currentPlayer: 'player1',
                player1Score: 0,
                player2Score: 0,
                matchedCards: [],
                lastMove: null,
                gameStarted: false
            };

            await window.firebaseSet(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode), roomData);
            
            document.getElementById('roomModal').classList.remove('show');
            document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
            document.getElementById('waitingModal').classList.add('show');

            listenToRoom();
        };

        window.showJoinInput = function() {
            document.getElementById('joinInput').style.display = 'block';
        };

        window.hideJoinInput = function() {
            document.getElementById('joinInput').style.display = 'none';
            document.getElementById('roomCodeInput').value = '';
        };

        window.joinRoom = async function() {
            const code = document.getElementById('roomCodeInput').value.toUpperCase().trim();
            if (!code) return;

            const roomRef = window.firebaseRef(window.firebaseDb, 'rooms/' + code);
            const snapshot = await window.firebaseGet(roomRef);
            
            if (!snapshot.exists()) {
                alert('Room not found! Check the code and try again.');
                return;
            }

            const roomData = snapshot.val();
            if (roomData.player2) {
                alert('This room is already full!');
                return;
            }

            playerId = generatePlayerId();
            currentRoomCode = code;
            playerRole = 'player2';

            await window.firebaseUpdate(roomRef, {
                player2: playerId,
                gameStarted: true,
                currentPlayer: Math.random() < 0.5 ? 'player1' : 'player2'
            });

            document.getElementById('roomModal').classList.remove('show');
            document.getElementById('joinInput').style.display = 'none';
            document.getElementById('roomCodeInput').value = '';

            listenToRoom();
            initOnlineGame(roomData);
        };

        window.cancelRoom = function() {
            if (currentRoomCode) {
                window.firebaseRemove(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode));
            }
            currentRoomCode = null;
            document.getElementById('waitingModal').classList.remove('show');
            document.getElementById('modeSelect').value = 'solo';
            // Hide chat when canceling online game
            if (chatToggle) chatToggle.classList.add('hidden');
            if (chatWindow) chatWindow.classList.add('hidden');
            initGame();
        };
        
        window.copyRoomCode = function() {
            navigator.clipboard.writeText(currentRoomCode);
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '‚úì Copied!';
            btn.classList.add('copied');
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('copied');
            }, 2000);
        };

        function listenToRoom() {
            const roomRef = window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode);
            roomListener = window.firebaseOnValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert('The game room has been closed.');
                    currentRoomCode = null;
                    document.getElementById('waitingModal').classList.remove('show');
                    document.getElementById('modeSelect').value = 'solo';
                    initGame();
                    return;
                }

                const roomData = snapshot.val();
                
                if (playerRole === 'player1' && roomData.player2 && roomData.gameStarted) {
                    document.getElementById('waitingModal').classList.remove('show');
                    initOnlineGame(roomData);
                }

                if (roomData.gameStarted && onlineMode) {
                    updateGameFromRoom(roomData);
                }
            });
        }

        function initOnlineGame(roomData) {
            onlineMode = true;
            gameMode = 'vs-friend';
            previouslyMatchedCards = [];
            
            initChatListener(currentRoomCode);

            document.getElementById('sizeSelect').value = roomData.gridSize;
            document.getElementById('themeSelect').value = roomData.theme;

            const size = gridSizes[roomData.gridSize];
            totalPairs = size.pairs;
            cards = roomData.cards;

            currentPlayer = roomData.currentPlayer;
            playerMatches = roomData.player1Score || 0;
            opponentMatches = roomData.player2Score || 0;

            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            flippedCards = [];
            canFlip = true;

            gameBoard.style.gridTemplateColumns = `repeat(${size.cols}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${size.rows}, 1fr)`;

            const soloStats = document.getElementById('soloStats');
            const vsStats = document.getElementById('vsStats');
            soloStats.style.display = 'none';
            vsStats.style.display = '';
            document.getElementById('playerScore').textContent = playerRole === 'player1' ? roomData.player1Score : roomData.player2Score;
            document.getElementById('opponentScore').textContent = playerRole === 'player1' ? roomData.player2Score : roomData.player1Score;

            updateTurnIndicator();

            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                if (roomData.matchedCards && roomData.matchedCards.includes(index)) {
                    card.classList.add('matched');
                }
                
                card.innerHTML = `
                    <div class="card-face card-back">?</div>
                    <div class="card-face card-front">${symbol}</div>
                `;
                
                card.addEventListener('click', () => flipCardOnline(card));
                gameBoard.appendChild(card);
            });
        }

        function updateGameFromRoom(roomData) {
            if (!onlineMode) return;
        
            currentPlayer = roomData.currentPlayer;
            const myScore = playerRole === 'player1' ? (roomData.player1Score || 0) : (roomData.player2Score || 0);
            const theirScore = playerRole === 'player1' ? (roomData.player2Score || 0) : (roomData.player1Score || 0);
            
            document.getElementById('playerScore').textContent = myScore;
            document.getElementById('opponentScore').textContent = theirScore;
        
            playerMatches = myScore;
            opponentMatches = theirScore;
        
            updateTurnIndicator();

            const lastMove = roomData.lastMove || null;
            const moveKey = lastMove ? `${lastMove.player}|${lastMove.cards?.join(',')}|${lastMove.matched}` : null;
            if (lastMove && lastMove.player !== playerId && moveKey !== lastProcessedMove) {
                lastProcessedMove = moveKey;
                const [i1, i2] = lastMove.cards || [];
                const c1 = document.querySelector(`[data-index="${i1}"]`);
                const c2 = document.querySelector(`[data-index="${i2}"]`);
                if (c1 && c2) {
                    // always show reveal, even if matchedCards already includes them
                    c1.classList.remove('matched');
                    c2.classList.remove('matched');
                    c1.classList.add('flipped');
                    c2.classList.add('flipped');
        
                    if (lastMove.matched) {
                        // pause to show reveal, then mark matched
                        setTimeout(() => {
                            c1.classList.add('matched');
                            c2.classList.add('matched');
                            c1.classList.remove('flipped');
                            c2.classList.remove('flipped');
                        }, 700);
                    } else {
                        setTimeout(() => {
                            c1.classList.remove('flipped');
                            c2.classList.remove('flipped');
                        }, 1000);
                    }
                }
            } else if (lastMove && lastMove.player === playerId) {
                // My own move came back from Firebase √¢‚Ç¨‚Äù just ensure those cards stay matched
                if (lastMove.matched && Array.isArray(lastMove.cards)) {
                    lastMove.cards.forEach(i => {
                        const card = document.querySelector(`[data-index="${i}"]`);
                        if (card) card.classList.add('matched');
                    });
                }
            }
        
            // Apply matchedCards only for *other* already finished moves
            if (roomData.matchedCards && Array.isArray(roomData.matchedCards)) {
                roomData.matchedCards.forEach(idx => {
                    // Skip cards from current lastMove.matched so animation can play
                    if (lastMove?.matched && lastMove.cards?.includes(idx)) return;
                    const card = document.querySelector(`[data-index="${idx}"]`);
                    if (card && !card.classList.contains('matched')) card.classList.add('matched');
                });
            }
        
            // check for end of game
            const totalMatches = (roomData.player1Score || 0) + (roomData.player2Score || 0);
            if (totalMatches === totalPairs) {
                setTimeout(() => showOnlineWinMessage(roomData), 500);
            }
        }


        async function flipCardOnline(card) {
            if (!canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) {
                return;
            }
        
            const isMyTurn = (playerRole === 'player1' && currentPlayer === 'player1') || 
                            (playerRole === 'player2' && currentPlayer === 'player2');
            
            if (!isMyTurn) {
                return;
            }
        
            card.classList.add('flipped');
            flippedCards.push(card);
        
            if (flippedCards.length === 2) {
                canFlip = false;
                const card1 = flippedCards[0];
                const card2 = flippedCards[1];
                const symbol1 = card1.dataset.symbol;
                const symbol2 = card2.dataset.symbol;
                const index1 = parseInt(card1.dataset.index);
                const index2 = parseInt(card2.dataset.index);
        
                const roomRef = window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode);
                const snapshot = await window.firebaseGet(roomRef);
                const roomData = snapshot.val();
        
                const scoreKey = playerRole === 'player1' ? 'player1Score' : 'player2Score';
                const newScore = (roomData && roomData[scoreKey] ? roomData[scoreKey] : 0);
        
                if (symbol1 === symbol2) {
                    // 1) Write lastMove+score to Firebase immediately so observers can reveal
                    const lastMoveObj = {
                        player: playerId,
                        cards: [index1, index2],
                        matched: true,
                        time: Date.now()
                    };
        
                    await window.firebaseUpdate(roomRef, {
                        [scoreKey]: newScore + 1,
                        lastMove: lastMoveObj,
                        currentPlayer: playerRole // keep turn with same player for match
                    });
        
                    // 2) Wait a bit so other clients see the reveal animation,
                    //    then write matchedCards (so the cards actually disappear for everyone)
                    setTimeout(async () => {
                        const snap2 = await window.firebaseGet(roomRef);
                        const roomData2 = snap2.val();
                        const matchedCards = roomData2 && roomData2.matchedCards ? roomData2.matchedCards.slice() : [];
                        matchedCards.push(index1, index2);
                        await window.firebaseUpdate(roomRef, {
                            matchedCards: matchedCards
                        });
        
                        // update local UI for the player who made the match
                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        flippedCards = [];
                        canFlip = true;
                    }, 700); // 700 ms gives remote client time to animate
                } else {
                    // Not a match: flip back locally after small delay and hand turn to opponent
                    const lastMoveObj = {
                        player: playerId,
                        cards: [index1, index2],
                        matched: false,
                        time: Date.now()
                    };
        
                    setTimeout(async () => {
                        await window.firebaseUpdate(roomRef, {
                            currentPlayer: playerRole === 'player1' ? 'player2' : 'player1',
                            lastMove: lastMoveObj
                        });
        
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        flippedCards = [];
                        canFlip = true;
                    }, 1000);
                }
            }
        }

        function showOnlineWinMessage(roomData) {
            const myScore = playerRole === 'player1' ? roomData.player1Score : roomData.player2Score;
            const theirScore = playerRole === 'player1' ? roomData.player2Score : roomData.player1Score;
            
            const winTitle = document.getElementById('winTitle');
            const winContent = document.getElementById('winContent');
            const scoreTextEl = document.getElementById('scoreText');
            
            const gridSize = document.getElementById('sizeSelect').value;
            const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
            
            if (myScore > theirScore) {
                winTitle.textContent = 'üéâ You Win!';
            } else if (theirScore > myScore) {
                winTitle.textContent = 'üò¢ You Lose!';
            } else {
                winTitle.textContent = 'ü§ù Tie Game!';
            }
            
            winContent.innerHTML = `
                <p>Final Score:</p>
                <p>You: ${myScore}</p>
                <p>Opponent: ${theirScore}</p>
            `;
            
            finalScoreText = `Memory Game - VS Friend Online
Grid: ${gridSize}
Theme: ${theme}
Final Score:
  You: ${myScore}
  Opponent: ${theirScore}
Result: ${myScore > theirScore ? 'You Win!' : theirScore > myScore ? 'You Lose!' : 'Tie!'}`;
            
            scoreTextEl.textContent = finalScoreText;
            document.getElementById('winMessage').classList.add('show');

            if (currentRoomCode) {
                window.firebaseRemove(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode));
                currentRoomCode = null;
            }
        }

        function getCurrentTheme() {
            const select = document.getElementById('themeSelect');
            return themes[select.value];
        }

        function getCurrentGridSize() {
            const select = document.getElementById('sizeSelect');
            return gridSizes[select.value];
        }

        function getRandomTheme() {
            const themeKeys = Object.keys(themes);
            const randomIndex = Math.floor(Math.random() * themeKeys.length);
            return themeKeys[randomIndex];
        }

        function getRandomGridSize() {
            const sizeKeys = Object.keys(gridSizes);
            const randomIndex = Math.floor(Math.random() * sizeKeys.length);
            return sizeKeys[randomIndex];
        }

        function setRandomTheme() {
            const select = document.getElementById('themeSelect');
            select.value = getRandomTheme();
        }

        function setRandomGridSize() {
            const select = document.getElementById('sizeSelect');
            select.value = getRandomGridSize();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function getElapsedTime() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const turnText = document.getElementById('turnText');
            
            if (gameMode === 'vs-friend') {
                indicator.style.display = 'inline-block';
                const isMyTurn = (playerRole === 'player1' && currentPlayer === 'player1') || 
                                (playerRole === 'player2' && currentPlayer === 'player2');
                turnText.textContent = isMyTurn ? 'Your Turn' : 'Opponent Turn';
            } else if (gameMode !== 'solo') {
                indicator.style.display = 'inline-block';
                turnText.textContent = currentPlayer === 'human' ? 'Your Turn' : 'Computer Turn';
            } else {
                indicator.style.display = 'none';
            }
        }

        window.initGame = function() {
            // Always hide chat UI first (will be shown only in vs-friend mode)
            if (chatToggle) chatToggle.classList.add('hidden');
            if (chatWindow) chatWindow.classList.add('hidden');
            
            if (onlineMode) {
                if (currentRoomCode) {
                    window.firebaseRemove(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode));
                    currentRoomCode = null;
                }
                onlineMode = false;
            }

            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            flippedCards = [];
            moves = 0;
            playerMatches = 0;
            opponentMatches = 0;
            computerMemory = {};
            computerMemoryTurns = {};
            turnNumber = 0;
            canFlip = true;
            
            stopTimer();
            
            const modeSelect = document.getElementById('modeSelect').value;
            
            if (modeSelect === 'solo') {
                gameMode = 'solo';
                difficulty = null;
            } else if (modeSelect === 'vs-friend') {
                return;
            } else {
                gameMode = 'vs';
                if (modeSelect === 'vs-easy') difficulty = 'easy';
                else if (modeSelect === 'vs-medium') difficulty = 'medium';
                else if (modeSelect === 'vs-hard') difficulty = 'hard';
            }
            
            const gridSize = getCurrentGridSize();
            const symbols = getCurrentTheme();
            totalPairs = gridSize.pairs;

            if (gameMode === 'vs') {
                currentPlayer = Math.random() < 0.5 ? 'human' : 'computer';
            } else {
                currentPlayer = 'human';
            }

            gameBoard.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${gridSize.rows}, 1fr)`;
            
            const soloStats = document.getElementById('soloStats');
            const vsStats = document.getElementById('vsStats');
            
            if (gameMode === 'solo') {
                soloStats.style.display = '';
                vsStats.style.display = 'none';
                document.getElementById('moves').textContent = '0';
                document.getElementById('timer').textContent = '0:00';
                startTimer();
            } else {
                soloStats.style.display = 'none';
                vsStats.style.display = '';
                document.getElementById('playerScore').textContent = '0';
                document.getElementById('opponentScore').textContent = '0';
            }
            
            updateTurnIndicator();
            document.getElementById('winMessage').classList.remove('show');

            const cardSymbols = [];
            for (let i = 0; i < gridSize.pairs; i++) {
                cardSymbols.push(symbols[i], symbols[i]);
            }

            cards = shuffle(cardSymbols);

            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                card.innerHTML = `
                    <div class="card-face card-back">?</div>
                    <div class="card-face card-front">${symbol}</div>
                `;
                
                card.addEventListener('click', () => flipCard(card));
                gameBoard.appendChild(card);
            });

            if (gameMode === 'vs' && currentPlayer === 'computer') {
                setTimeout(computerTurn, 1000);
            }
        };

        function flipCard(card) {
            if (!canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) {
                return;
            }

            if (gameMode === 'vs' && currentPlayer !== 'human') {
                return;
            }

            card.classList.add('flipped');
            flippedCards.push(card);

            if (gameMode === 'vs') {
                const index = card.dataset.index;
                const symbol = card.dataset.symbol;
                computerMemory[index] = symbol;
                computerMemoryTurns[index] = turnNumber;
            }

            if (flippedCards.length === 2) {
                canFlip = false;
                checkMatch();
            }
        }

        function checkMatch() {
            const [card1, card2] = flippedCards;
            const symbol1 = card1.dataset.symbol;
            const symbol2 = card2.dataset.symbol;
        
            if (symbol1 === symbol2) {
                setTimeout(() => {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
        
                    if (gameMode === 'solo') {
                        moves++;
                        document.getElementById('moves').textContent = moves;
                    } else if (gameMode === 'vs') {
                        if (currentPlayer === 'human') {
                            playerMatches++;
                            document.getElementById('playerScore').textContent = playerMatches;
                        } else {
                            opponentMatches++;
                            document.getElementById('opponentScore').textContent = opponentMatches;
                        }
                    }
        
                    flippedCards = [];
                    canFlip = true;
        
                    // Check win condition *after* the DOM updates have completed
                    setTimeout(() => {
                        const matchedPairs = document.querySelectorAll('.card.matched').length / 2;
                        if (matchedPairs === totalPairs) {
                            stopTimer();
                            showWinMessage();
                        } else if (gameMode === 'vs' && currentPlayer === 'computer') {
                            setTimeout(computerTurn, 800);
                        }
                    }, 300);
                }, 500);
            } else {
                turnNumber++;
                if (gameMode === 'solo') {
                    moves++;
                    document.getElementById('moves').textContent = moves;
                }
        
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                    flippedCards = [];
                    canFlip = true;
        
                    if (gameMode === 'vs') {
                        currentPlayer = currentPlayer === 'human' ? 'computer' : 'human';
                        updateTurnIndicator();
                        if (currentPlayer === 'computer') {
                            setTimeout(computerTurn, 800);
                        }
                    }
                }, 1000);
            }
        }



        function computerTurn() {
            if (currentPlayer !== 'computer' || !canFlip) return;

            if (difficulty === 'hard') {
                computerTurnHard();
            } else if (difficulty === 'medium') {
                computerTurnMedium();
            } else {
                computerTurnEasy();
            }
        }

        function getComputerMemory() {
            if (difficulty === 'easy') {
                const recentMemory = {};
                for (const [index, symbol] of Object.entries(computerMemory)) {
                    if (turnNumber - computerMemoryTurns[index] <= 4) {
                        recentMemory[index] = symbol;
                    }
                }
                return recentMemory;
            } else {
                return computerMemory;
            }
        }

        function computerTurnMedium() {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            const knownPairs = findKnownPairWithMemory(memory);
            
            let card1, card2;
            
            if (knownPairs) {
                [card1, card2] = knownPairs;
            } else {
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                if (unseenCards.length >= 2) {
                    card1 = unseenCards[0];
                    card2 = unseenCards[1];
                } else if (unseenCards.length === 1) {
                    card1 = unseenCards[0];
                    const otherCards = Array.from(allCards).filter(c => c !== card1);
                    card2 = otherCards[Math.floor(Math.random() * otherCards.length)];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                    const remaining = cardsArray.filter(c => c !== card1);
                    card2 = remaining[Math.floor(Math.random() * remaining.length)];
                }
            }

            setTimeout(() => {
                card1.classList.add('flipped');
                flippedCards.push(card1);
                computerMemory[card1.dataset.index] = card1.dataset.symbol;
                computerMemoryTurns[card1.dataset.index] = turnNumber;

                setTimeout(() => {
                    card2.classList.add('flipped');
                    flippedCards.push(card2);
                    computerMemory[card2.dataset.index] = card2.dataset.symbol;
                    computerMemoryTurns[card2.dataset.index] = turnNumber;
                    
                    canFlip = false;
                    checkMatch();
                }, 600);
            }, 400);
        }

        function computerTurnHard() {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            const knownPairs = findKnownPairWithMemory(memory);
            
            if (knownPairs) {
                const [card1, card2] = knownPairs;
                
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    computerMemory[card1.dataset.index] = card1.dataset.symbol;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            } else {
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                let card1;
                if (unseenCards.length > 0) {
                    card1 = unseenCards[0];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                }

                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    const symbol1 = card1.dataset.symbol;
                    computerMemory[card1.dataset.index] = symbol1;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    let card2 = null;
                    const updatedMemory = getComputerMemory();
                    
                    for (const card of allCards) {
                        if (card === card1 || card.classList.contains('matched')) continue;
                        const idx = card.dataset.index;
                        if (updatedMemory[idx] === symbol1) {
                            card2 = card;
                            break;
                        }
                    }

                    if (!card2) {
                        const remainingUnseen = Array.from(allCards).filter(c => 
                            c !== card1 && !updatedMemory[c.dataset.index]
                        );
                        
                        if (remainingUnseen.length > 0) {
                            card2 = remainingUnseen[0];
                        } else {
                            const remaining = Array.from(allCards).filter(c => c !== card1);
                            card2 = remaining[Math.floor(Math.random() * remaining.length)];
                        }
                    }

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            }
        }

        function computerTurnEasy() {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            const knownPairs = findKnownPairWithMemory(memory);
            
            if (knownPairs) {
                const [card1, card2] = knownPairs;
                
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    computerMemory[card1.dataset.index] = card1.dataset.symbol;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            } else {
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                let card1;
                if (unseenCards.length > 0) {
                    card1 = unseenCards[0];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                }

                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    const symbol1 = card1.dataset.symbol;
                    computerMemory[card1.dataset.index] = symbol1;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    let card2 = null;
                    const updatedMemory = getComputerMemory();
                    
                    for (const card of allCards) {
                        if (card === card1 || card.classList.contains('matched')) continue;
                        const idx = card.dataset.index;
                        if (updatedMemory[idx] === symbol1) {
                            card2 = card;
                            break;
                        }
                    }

                    if (!card2) {
                        const remainingUnseen = Array.from(allCards).filter(c => 
                            c !== card1 && !updatedMemory[c.dataset.index]
                        );
                        
                        if (remainingUnseen.length > 0) {
                            card2 = remainingUnseen[0];
                        } else {
                            const remaining = Array.from(allCards).filter(c => c !== card1);
                            card2 = remaining[Math.floor(Math.random() * remaining.length)];
                        }
                    }

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            }
        }

        function findKnownPairWithMemory(memory) {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const symbolLocations = {};

            for (const card of allCards) {
                const index = card.dataset.index;
                if (memory[index] !== undefined) {
                    const symbol = memory[index];
                    if (!symbolLocations[symbol]) {
                        symbolLocations[symbol] = [];
                    }
                    symbolLocations[symbol].push(card);
                }
            }

            for (const symbol in symbolLocations) {
                if (symbolLocations[symbol].length >= 2) {
                    return [symbolLocations[symbol][0], symbolLocations[symbol][1]];
                }
            }

            return null;
        }

        function showWinMessage() {
            stopTimer();
            
            const winTitle = document.getElementById('winTitle');
            const winContent = document.getElementById('winContent');
            const scoreTextEl = document.getElementById('scoreText');
            
            if (gameMode === 'solo') {
                const elapsedTime = getElapsedTime();
                const gridSize = document.getElementById('sizeSelect').value;
                const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
                
                winTitle.textContent = 'Congratulations!';
                winContent.innerHTML = `
                    <p>You completed the game!</p>
                    <p>Time: ${elapsedTime}</p>
                    <p>Moves: ${moves}</p>
                `;
                
                finalScoreText = `Memory Game - Solo Mode
                Grid: ${gridSize}
                Theme: ${theme}
                Time: ${elapsedTime}
                Moves: ${moves}`;
                } else {
                const gridSize = document.getElementById('sizeSelect').value;
                const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
                const difficultyText = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                
                if (playerMatches > opponentMatches) {
                    winTitle.textContent = 'üéâ You Win!';
                } else if (opponentMatches > playerMatches) {
                    winTitle.textContent = 'ü§ñ Computer Wins!';
                } else {
                    winTitle.textContent = 'ü§ù Tie Game!';
                }
                
                winContent.innerHTML = `
                    <p>Final Score:</p>
                    <p>You: ${playerMatches}</p>
                    <p>Computer: ${opponentMatches}</p>
                `;
                
                finalScoreText = `Memory Game - VS ${difficultyText} Computer
                Grid: ${gridSize}
                Theme: ${theme}
                Final Score:
                  You: ${playerMatches}
                  Computer: ${opponentMatches}
                Result: ${playerMatches > opponentMatches ? 'You Win!' : opponentMatches > playerMatches ? 'Computer Wins!' : 'Tie!'}`;
                            }
            
            scoreTextEl.textContent = finalScoreText;
            document.getElementById('winMessage').classList.add('show');
            
            if (chatWindow) chatWindow.classList.add('hidden');
            if (chatToggle) chatToggle.classList.add('hidden');
        }


        window.copyScore = function() {
            navigator.clipboard.writeText(finalScoreText).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.classList.add('copied');
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard');
            });
        };

        setRandomTheme();
        setRandomGridSize();
        initGame();
        
    </script>
    
    <!-- === Chat UI (Vs Friend mode only) === -->
    <div id="chat-toggle" class="chat-toggle hidden" title="Chat">üí¨</div>
    <div id="chat-window" class="chat-window hidden">
      <div id="chat-header">
        <span>Chat</span>
        <span id="chat-close" class="chat-close">‚úñ</span>
      </div>
      <div id="chat-messages"></div>
      <div id="chat-input-row">
        <input id="chat-input" type="text" placeholder="Type a message..." />
        <button id="chat-send">Send</button>
      </div>
    </div>

</body>
</html>