<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .mode-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
        }

        .mode-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .mode-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .theme-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
        }

        .theme-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .theme-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .size-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
            margin-left: 10px;
        }

        .size-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .size-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .stats {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: inline-block;
        }

        .stats span {
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 15px;
        }

        .turn-indicator {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 10px 25px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: inline-block;
            min-width: 180px;
        }

        .turn-indicator span {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
        }

        .game-board {
            display: grid;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
        }

        .card {
            aspect-ratio: 1;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.matched {
            opacity: 0;
            pointer-events: none;
            transform: scale(0);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .card.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            font-size: 3em;
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .card-front {
            background: white;
            transform: rotateY(180deg);
        }

        .restart-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .restart-btn:active {
            transform: translateY(0);
        }

        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
            z-index: 1000;
            max-width: 90%;
        }

        .win-message.show {
            display: block;
            animation: popup 0.5s ease;
        }

        @keyframes popup {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .win-message h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .win-message p {
            color: #666;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .score-text {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 1em;
            color: #333;
            white-space: pre-line;
            text-align: left;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .copy-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .copy-btn.copied {
            background: #4CAF50;
        }

        @media (max-width: 600px) {
            .game-board {
                gap: 5px;
                padding: 10px;
            }

            .card-face {
                font-size: 2em;
            }

            h1 {
                font-size: 2em;
            }

            .win-message {
                padding: 30px 40px;
            }

            .win-message h2 {
                font-size: 2em;
            }

            .win-message p {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Memory Game</h1>
        
        <div class="mode-selector">
            <label for="modeSelect">Game Mode:</label>
            <select id="modeSelect" onchange="initGame()">
                <option value="solo">Solo</option>
                <option value="vs-easy">VS Easy Computer</option>
                <option value="vs-medium">VS Medium Computer</option>
                <option value="vs-hard">VS Hard Computer</option>
            </select>
        </div>

        <div class="theme-selector">
            <label for="themeSelect">Theme:</label>
            <select id="themeSelect" onchange="initGame()">
                <option value="fruits">üçé Fruits</option>
                <option value="dinosaurs">ü¶ï Dinosaurs</option>
                <option value="trucks">üöö Trucks</option>
                <option value="space">üöÄ Space</option>
                <option value="faces">üòÄ Faces</option>
            </select>
        </div>

        <div class="size-selector">
            <label for="sizeSelect">Grid Size:</label>
            <select id="sizeSelect" onchange="initGame()">
                <option value="3x4">3x4</option>
                <option value="4x4">4x4</option>
                <option value="4x5">4x5</option>
                <option value="5x6">5x6</option>
                <option value="6x6">6x6</option>
            </select>
        </div>

        <div class="turn-indicator" id="turnIndicator" style="display: none;">
            <span id="turnText">Your Turn</span>
        </div>

        <div class="stats" id="stats">
            <span id="soloStats">
                <span>Moves: <span id="moves">0</span></span>
                <span>Time: <span id="timer">0:00</span></span>
            </span>
            <span id="vsStats" style="display: none;">
                <span>You: <span id="playerScore">0</span></span>
                <span>Computer: <span id="computerScore">0</span></span>
            </span>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <button class="restart-btn" onclick="initGame()">New Game</button>
    </div>

    <div class="win-message" id="winMessage">
        <h2 id="winTitle">üéâ Congratulations!</h2>
        <div id="winContent"></div>
        <div class="score-text" id="scoreText"></div>
        <div class="button-group">
            <button class="copy-btn" id="copyBtn" onclick="copyScore()">Copy Score</button>
            <button class="restart-btn" onclick="initGame()">Play Again</button>
        </div>
    </div>

    <script>
        const themes = {
            fruits: ['üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'üçí', 'üçë', 'ü•ù', 'üçâ', 'üçç', 'ü•≠', 'üçê', 'ü••', 'üçã', 'ü´ê', 'üçà', 'ü•ë', 'üçÖ'],
            dinosaurs: ['ü¶ï', 'ü¶ñ', 'ü¶¥', 'ü¶é', 'üêä', 'üê¢', 'ü¶è', 'ü¶ò', 'üêâ', 'ü¶§', 'üê≤', 'ü¶í', 'üêç', 'ü¶é', 'üê∏', 'ü¶Ç', 'üï∑Ô∏è', 'ü¶ó'],
            trucks: ['üöö', 'üöõ', 'üöú', 'üöó', 'üöô', 'üöï', 'üöê', 'üöí', 'üöì', 'üöë', 'üèéÔ∏è', 'üöå', 'üöé', 'üèçÔ∏è', 'üõµ', 'üö≤', 'üõ¥', 'üöÇ'],
            space: ['üöÄ', 'üõ∏', 'üåü', '‚≠ê', 'üåô', 'ü™ê', 'üåç', 'üëΩ', 'üõ∞Ô∏è', '‚òÑÔ∏è', 'üåå', 'üî≠', 'üå†', 'üåï', 'üåé', 'üåè', '‚òÄÔ∏è', '‚ú®'],
            faces: ['üòÄ', 'ü•∞', 'üòè', 'üò≠', 'üò°', 'ü§¢', 'üò±', 'ü•≥', 'ü§Ø', 'üò¥', 'ü§ì', 'ü§ó', 'üòµ', 'ü§ê', 'ü•∫', 'ü§™', 'üòá', 'ü§§']
        };

        const gridSizes = {
            '3x4': { rows: 4, cols: 3, pairs: 6 },
            '4x4': { rows: 4, cols: 4, pairs: 8 },
            '4x5': { rows: 5, cols: 4, pairs: 10 },
            '5x6': { rows: 6, cols: 5, pairs: 15 },
            '6x6': { rows: 6, cols: 6, pairs: 18 }
        };
        
        let cards = [];
        let flippedCards = [];
        let moves = 0;
        let totalPairs = 0;
        let canFlip = true;
        let gameMode = 'solo';
        let currentPlayer = 'human';
        let playerMatches = 0;
        let computerMatches = 0;
        let computerMemory = {};
        let computerMemoryTurns = {}; // Track when each card was seen (for Easy mode)
        let turnNumber = 0;
        let difficulty = 'medium';
        let startTime = null;
        let timerInterval = null;
        let finalScoreText = '';

        function getCurrentTheme() {
            const select = document.getElementById('themeSelect');
            return themes[select.value];
        }

        function getCurrentGridSize() {
            const select = document.getElementById('sizeSelect');
            return gridSizes[select.value];
        }

        function getRandomTheme() {
            const themeKeys = Object.keys(themes);
            const randomIndex = Math.floor(Math.random() * themeKeys.length);
            return themeKeys[randomIndex];
        }

        function getRandomGridSize() {
            const sizeKeys = Object.keys(gridSizes);
            const randomIndex = Math.floor(Math.random() * sizeKeys.length);
            return sizeKeys[randomIndex];
        }

        function setRandomTheme() {
            const select = document.getElementById('themeSelect');
            select.value = getRandomTheme();
        }

        function setRandomGridSize() {
            const select = document.getElementById('sizeSelect');
            select.value = getRandomGridSize();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function getElapsedTime() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const turnText = document.getElementById('turnText');
            
            if (gameMode === 'vs') {
                indicator.style.display = 'inline-block';
                turnText.textContent = currentPlayer === 'human' ? 'Your Turn' : 'Computer Turn';
            } else {
                indicator.style.display = 'none';
            }
        }

        function initGame() {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            flippedCards = [];
            moves = 0;
            playerMatches = 0;
            computerMatches = 0;
            computerMemory = {};
            computerMemoryTurns = {};
            turnNumber = 0;
            canFlip = true;
            
            stopTimer();
            
            const modeSelect = document.getElementById('modeSelect').value;
            
            // Parse mode and difficulty
            if (modeSelect === 'solo') {
                gameMode = 'solo';
                difficulty = null;
            } else {
                gameMode = 'vs';
                if (modeSelect === 'vs-easy') difficulty = 'easy';
                else if (modeSelect === 'vs-medium') difficulty = 'medium';
                else if (modeSelect === 'vs-hard') difficulty = 'hard';
            }
            
            const gridSize = getCurrentGridSize();
            const symbols = getCurrentTheme();
            totalPairs = gridSize.pairs;

            // Randomly decide who starts in VS mode
            if (gameMode === 'vs') {
                currentPlayer = Math.random() < 0.5 ? 'human' : 'computer';
            } else {
                currentPlayer = 'human';
            }

            // Set up the grid
            gameBoard.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${gridSize.rows}, 1fr)`;
            
            // Update UI based on mode
            const soloStats = document.getElementById('soloStats');
            const vsStats = document.getElementById('vsStats');
            
            if (gameMode === 'solo') {
                soloStats.style.display = '';
                vsStats.style.display = 'none';
                document.getElementById('moves').textContent = '0';
                document.getElementById('timer').textContent = '0:00';
                startTimer();
            } else {
                soloStats.style.display = 'none';
                vsStats.style.display = '';
                document.getElementById('playerScore').textContent = '0';
                document.getElementById('computerScore').textContent = '0';
            }
            
            updateTurnIndicator();
            document.getElementById('winMessage').classList.remove('show');

            // Create pairs
            const cardSymbols = [];
            for (let i = 0; i < gridSize.pairs; i++) {
                cardSymbols.push(symbols[i], symbols[i]);
            }

            cards = shuffle(cardSymbols);

            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                card.innerHTML = `
                    <div class="card-face card-back">?</div>
                    <div class="card-face card-front">${symbol}</div>
                `;
                
                card.addEventListener('click', () => flipCard(card));
                gameBoard.appendChild(card);
            });

            // If computer starts, trigger computer turn
            if (gameMode === 'vs' && currentPlayer === 'computer') {
                setTimeout(computerTurn, 1000);
            }
        }

        function flipCard(card) {
            if (!canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) {
                return;
            }

            // In VS mode, only allow flipping if it's human's turn
            if (gameMode === 'vs' && currentPlayer !== 'human') {
                return;
            }

            card.classList.add('flipped');
            flippedCards.push(card);

            // Store in computer memory in VS mode
            if (gameMode === 'vs') {
                const index = card.dataset.index;
                const symbol = card.dataset.symbol;
                computerMemory[index] = symbol;
                computerMemoryTurns[index] = turnNumber;
            }

            if (flippedCards.length === 2) {
                canFlip = false;
                checkMatch();
            }
        }

        function checkMatch() {
            const [card1, card2] = flippedCards;
            const symbol1 = card1.dataset.symbol;
            const symbol2 = card2.dataset.symbol;

            if (symbol1 === symbol2) {
                // Match found
                setTimeout(() => {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    
                    if (gameMode === 'solo') {
                        moves++;
                    } else {
                        if (currentPlayer === 'human') {
                            playerMatches++;
                            document.getElementById('playerScore').textContent = playerMatches;
                        } else {
                            computerMatches++;
                            document.getElementById('computerScore').textContent = computerMatches;
                        }
                    }
                    
                    flippedCards = [];
                    canFlip = true;

                    const totalMatches = gameMode === 'solo' ? moves : (playerMatches + computerMatches);
                    if (totalMatches === totalPairs) {
                        setTimeout(() => showWinMessage(), 500);
                    } else if (gameMode === 'vs') {
                        // Same player goes again after a match
                        if (currentPlayer === 'computer') {
                            setTimeout(computerTurn, 1000);
                        }
                    }
                }, 500);
            } else {
                // No match - increment turn number
                turnNumber++;
                
                if (gameMode === 'solo') {
                    moves++;
                    document.getElementById('moves').textContent = moves;
                }
                
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                    flippedCards = [];
                    canFlip = true;

                    // Switch players in VS mode
                    if (gameMode === 'vs') {
                        currentPlayer = currentPlayer === 'human' ? 'computer' : 'human';
                        updateTurnIndicator();
                        
                        if (currentPlayer === 'computer') {
                            setTimeout(computerTurn, 1000);
                        }
                    }
                }, 1000);
            }
        }

        function computerTurn() {
            if (currentPlayer !== 'computer' || !canFlip) return;

            if (difficulty === 'hard') {
                computerTurnHard();
            } else if (difficulty === 'medium') {
                computerTurnMedium();
            } else {
                computerTurnEasy();
            }
        }

        function getComputerMemory() {
            if (difficulty === 'easy') {
                // Easy mode: forget cards seen more than 4 turns ago
                const recentMemory = {};
                for (const [index, symbol] of Object.entries(computerMemory)) {
                    if (turnNumber - computerMemoryTurns[index] <= 4) {
                        recentMemory[index] = symbol;
                    }
                }
                return recentMemory;
            } else {
                // Medium and Hard: remember everything
                return computerMemory;
            }
        }

        function computerTurnMedium() {
            // Medium: Pick both cards first, then flip (original behavior)
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            // Check if computer knows any matching pairs
            const knownPairs = findKnownPairWithMemory(memory);
            
            let card1, card2;
            
            if (knownPairs) {
                [card1, card2] = knownPairs;
            } else {
                // Pick two cards the computer hasn't seen yet, or random if all seen
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                if (unseenCards.length >= 2) {
                    card1 = unseenCards[0];
                    card2 = unseenCards[1];
                } else if (unseenCards.length === 1) {
                    card1 = unseenCards[0];
                    const otherCards = Array.from(allCards).filter(c => c !== card1);
                    card2 = otherCards[Math.floor(Math.random() * otherCards.length)];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                    const remaining = cardsArray.filter(c => c !== card1);
                    card2 = remaining[Math.floor(Math.random() * remaining.length)];
                }
            }

            // Flip both cards with delay
            setTimeout(() => {
                card1.classList.add('flipped');
                flippedCards.push(card1);
                computerMemory[card1.dataset.index] = card1.dataset.symbol;
                computerMemoryTurns[card1.dataset.index] = turnNumber;

                setTimeout(() => {
                    card2.classList.add('flipped');
                    flippedCards.push(card2);
                    computerMemory[card2.dataset.index] = card2.dataset.symbol;
                    computerMemoryTurns[card2.dataset.index] = turnNumber;
                    
                    canFlip = false;
                    checkMatch();
                }, 600);
            }, 400);
        }

        function computerTurnHard() {
            // Hard: Flip first card, check memory, then decide second card intelligently
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            // Check if we already know a matching pair
            const knownPairs = findKnownPairWithMemory(memory);
            
            if (knownPairs) {
                // We know a match, play it
                const [card1, card2] = knownPairs;
                
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    computerMemory[card1.dataset.index] = card1.dataset.symbol;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            } else {
                // No known match, explore intelligently
                // Pick first card from unseen cards
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                let card1;
                if (unseenCards.length > 0) {
                    card1 = unseenCards[0];
                } else {
                    // All cards seen, pick randomly
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                }

                // Flip first card
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    const symbol1 = card1.dataset.symbol;
                    computerMemory[card1.dataset.index] = symbol1;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    // NOW check if we know where the matching card is
                    let card2 = null;
                    const updatedMemory = getComputerMemory();
                    
                    for (const card of allCards) {
                        if (card === card1 || card.classList.contains('matched')) continue;
                        const idx = card.dataset.index;
                        if (updatedMemory[idx] === symbol1) {
                            card2 = card;
                            break;
                        }
                    }

                    // If we don't know the match, pick from unseen cards
                    if (!card2) {
                        const remainingUnseen = Array.from(allCards).filter(c => 
                            c !== card1 && !updatedMemory[c.dataset.index]
                        );
                        
                        if (remainingUnseen.length > 0) {
                            card2 = remainingUnseen[0];
                        } else {
                            const remaining = Array.from(allCards).filter(c => c !== card1);
                            card2 = remaining[Math.floor(Math.random() * remaining.length)];
                        }
                    }

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            }
        }

        function computerTurnEasy() {
            // Easy: Same as Hard but with limited memory (forgets after 4 turns)
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory(); // This filters to recent 4 turns
            
            // Check if we know a matching pair from recent memory
            const knownPairs = findKnownPairWithMemory(memory);
            
            if (knownPairs) {
                const [card1, card2] = knownPairs;
                
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    computerMemory[card1.dataset.index] = card1.dataset.symbol;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            } else {
                // No known match in recent memory, explore
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                let card1;
                if (unseenCards.length > 0) {
                    card1 = unseenCards[0];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                }

                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    const symbol1 = card1.dataset.symbol;
                    computerMemory[card1.dataset.index] = symbol1;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    // Check recent memory for matching card
                    let card2 = null;
                    const updatedMemory = getComputerMemory();
                    
                    for (const card of allCards) {
                        if (card === card1 || card.classList.contains('matched')) continue;
                        const idx = card.dataset.index;
                        if (updatedMemory[idx] === symbol1) {
                            card2 = card;
                            break;
                        }
                    }

                    if (!card2) {
                        const remainingUnseen = Array.from(allCards).filter(c => 
                            c !== card1 && !updatedMemory[c.dataset.index]
                        );
                        
                        if (remainingUnseen.length > 0) {
                            card2 = remainingUnseen[0];
                        } else {
                            const remaining = Array.from(allCards).filter(c => c !== card1);
                            card2 = remaining[Math.floor(Math.random() * remaining.length)];
                        }
                    }

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            }
        }

        function findKnownPairWithMemory(memory) {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const symbolLocations = {};

            // Build a map of symbols to their card elements using provided memory
            for (const card of allCards) {
                const index = card.dataset.index;
                if (memory[index] !== undefined) {
                    const symbol = memory[index];
                    if (!symbolLocations[symbol]) {
                        symbolLocations[symbol] = [];
                    }
                    symbolLocations[symbol].push(card);
                }
            }

            // Find a symbol that appears twice
            for (const symbol in symbolLocations) {
                if (symbolLocations[symbol].length >= 2) {
                    return [symbolLocations[symbol][0], symbolLocations[symbol][1]];
                }
            }

            return null;
        }

        function showWinMessage() {
            stopTimer();
            
            const winTitle = document.getElementById('winTitle');
            const winContent = document.getElementById('winContent');
            const scoreTextEl = document.getElementById('scoreText');
            
            if (gameMode === 'solo') {
                const elapsedTime = getElapsedTime();
                const gridSize = document.getElementById('sizeSelect').value;
                const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
                
                winTitle.textContent = 'üéâ Congratulations!';
                winContent.innerHTML = `
                    <p>You completed the game!</p>
                    <p>Time: ${elapsedTime}</p>
                    <p>Moves: ${moves}</p>
                `;
                
                finalScoreText = `Memory Game - Solo Mode
Grid: ${gridSize}
Theme: ${theme}
Time: ${elapsedTime}
Moves: ${moves}`;
            } else {
                const gridSize = document.getElementById('sizeSelect').value;
                const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
                const difficultyText = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                
                if (playerMatches > computerMatches) {
                    winTitle.textContent = 'üéâ You Win!';
                } else if (computerMatches > playerMatches) {
                    winTitle.textContent = 'ü§ñ Computer Wins!';
                } else {
                    winTitle.textContent = 'ü§ù Tie Game!';
                }
                
                winContent.innerHTML = `
                    <p>Final Score:</p>
                    <p>You: ${playerMatches}</p>
                    <p>Computer: ${computerMatches}</p>
                `;
                
                finalScoreText = `Memory Game - VS ${difficultyText} Computer
Grid: ${gridSize}
Theme: ${theme}
Final Score:
  You: ${playerMatches}
  Computer: ${computerMatches}
Result: ${playerMatches > computerMatches ? 'You Win!' : computerMatches > playerMatches ? 'Computer Wins!' : 'Tie!'}`;
            }
            
            scoreTextEl.textContent = finalScoreText;
            document.getElementById('winMessage').classList.add('show');
        }

        function copyScore() {
            navigator.clipboard.writeText(finalScoreText).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úì Copied!';
                btn.classList.add('copied');
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard');
            });
        }

        setRandomTheme();
        setRandomGridSize();
        initGame();
    </script>
</body>
</html>