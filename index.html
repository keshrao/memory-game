<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .mode-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
        }

        .mode-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .mode-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .theme-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
        }

        .theme-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .theme-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .size-selector {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 15px;
            display: inline-block;
            margin-left: 10px;
        }

        .size-selector label {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            margin-right: 10px;
        }

        .size-selector select {
            padding: 8px 15px;
            font-size: 1em;
            border-radius: 8px;
            border: none;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .stats {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: inline-block;
        }

        .stats span {
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            margin: 0 15px;
        }

        .turn-indicator {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 10px 25px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: inline-block;
            min-width: 180px;
        }

        .turn-indicator span {
            color: white;
            font-size: 1.1em;
            font-weight: bold;
        }

        .game-board {
            display: grid;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
        }

        .card {
            aspect-ratio: 1;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.matched {
            opacity: 0;
            pointer-events: none;
            transform: scale(0);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        .card.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            font-size: 3em;
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .card-front {
            background: white;
            transform: rotateY(180deg);
        }

        .restart-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin: 5px;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .restart-btn:active {
            transform: translateY(0);
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            display: none;
            z-index: 1000;
            max-width: 90%;
        }

        .modal.show {
            display: block;
            animation: popup 0.5s ease;
        }

        @keyframes popup {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .modal h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        .modal p {
            color: #666;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .modal input {
            padding: 12px 20px;
            font-size: 1.1em;
            border: 2px solid #667eea;
            border-radius: 10px;
            margin: 10px 0;
            width: 100%;
            max-width: 300px;
            text-align: center;
            text-transform: uppercase;
        }

        .room-code {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 2em;
            color: #667eea;
            font-weight: bold;
            letter-spacing: 3px;
        }

        .score-text {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 1em;
            color: #333;
            white-space: pre-line;
            text-align: left;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .copy-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .copy-btn.copied {
            background: #4CAF50;
        }

        @media (max-width: 600px) {
            .game-board {
                gap: 5px;
                padding: 10px;
            }

            .card-face {
                font-size: 2em;
            }

            h1 {
                font-size: 2em;
            }

            .modal {
                padding: 30px 40px;
            }

            .modal h2 {
                font-size: 2em;
            }

            .modal p {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Memory Game</h1>
        
        <div class="mode-selector">
            <label for="modeSelect">Game Mode:</label>
            <select id="modeSelect" onchange="handleModeChange()">
                <option value="solo">Solo</option>
                <option value="vs-easy">VS Easy Computer</option>
                <option value="vs-medium">VS Medium Computer</option>
                <option value="vs-hard">VS Hard Computer</option>
                <option value="vs-friend">VS Friend Online</option>
            </select>
        </div>

        <div class="theme-selector">
            <label for="themeSelect">Theme:</label>
            <select id="themeSelect" onchange="handleSettingsChange()">
                <option value="fruits">ğŸ Fruits</option>
                <option value="dinosaurs">ğŸ¦• Dinosaurs</option>
                <option value="trucks">ğŸšš Trucks</option>
                <option value="space">ğŸš€ Space</option>
                <option value="faces">ğŸ˜€ Faces</option>
            </select>
        </div>

        <div class="size-selector">
            <label for="sizeSelect">Grid Size:</label>
            <select id="sizeSelect" onchange="handleSettingsChange()">
                <option value="3x4">3x4</option>
                <option value="4x4">4x4</option>
                <option value="4x5">4x5</option>
                <option value="5x6">5x6</option>
                <option value="6x6">6x6</option>
            </select>
        </div>

        <div class="turn-indicator" id="turnIndicator" style="display: none;">
            <span id="turnText">Your Turn</span>
        </div>

        <div class="stats" id="stats">
            <span id="soloStats">
                <span>Moves: <span id="moves">0</span></span>
                <span>Time: <span id="timer">0:00</span></span>
            </span>
            <span id="vsStats" style="display: none;">
                <span>You: <span id="playerScore">0</span></span>
                <span>Opponent: <span id="opponentScore">0</span></span>
            </span>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <button class="restart-btn" onclick="initGame()">New Game</button>
    </div>

    <!-- Room Selection Modal -->
    <div class="modal" id="roomModal">
        <h2>Play Online</h2>
        <p>Choose an option to play with a friend:</p>
        <div class="button-group">
            <button class="restart-btn" onclick="createRoom()">Create Game</button>
            <button class="restart-btn" onclick="showJoinInput()">Join Game</button>
        </div>
        <div id="joinInput" style="display: none; margin-top: 20px;">
            <input type="text" id="roomCodeInput" placeholder="Enter Room Code" maxlength="20">
            <div class="button-group">
                <button class="restart-btn" onclick="joinRoom()">Join</button>
                <button class="restart-btn" onclick="hideJoinInput()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Waiting Modal -->
    <div class="modal" id="waitingModal">
        <h2>Waiting for Friend...</h2>
        <p>Share this code with your friend:</p>
        <div class="room-code" id="roomCodeDisplay"></div>
        <div class="button-group">
            <button class="copy-btn" onclick="copyRoomCode()">Copy Code</button>
            <button class="restart-btn" onclick="cancelRoom()">Cancel</button>
        </div>
    </div>

    <!-- Win Message Modal -->
    <div class="modal" id="winMessage">
        <h2 id="winTitle">ğŸ‰ Congratulations!</h2>
        <div id="winContent"></div>
        <div class="score-text" id="scoreText"></div>
        <div class="button-group">
            <button class="copy-btn" id="copyBtn" onclick="copyScore()">Copy Score</button>
            <button class="restart-btn" onclick="initGame()">Play Again</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getDatabase, ref, set, onValue, update, remove, get } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBp8iDGPfzH84iGw0WGmDSp0QJfwTpTDdU",
            authDomain: "memory-game-21ee5.firebaseapp.com",
            databaseURL: "https://memory-game-21ee5-default-rtdb.firebaseio.com",
            projectId: "memory-game-21ee5",
            storageBucket: "memory-game-21ee5.appspot.com",
            messagingSenderId: "616933567051",
            appId: "1:616933567051:web:b1f215ae7dced7270bbbce"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Make Firebase functions available globally
        window.firebaseDb = database;
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseOnValue = onValue;
        window.firebaseUpdate = update;
        window.firebaseRemove = remove;
        window.firebaseGet = get;

        const themes = {
            fruits: ['ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸŠ', 'ğŸ“', 'ğŸ’', 'ğŸ‘', 'ğŸ¥', 'ğŸ‰', 'ğŸ', 'ğŸ¥­', 'ğŸ', 'ğŸ¥¥', 'ğŸ‹', 'ğŸ«', 'ğŸˆ', 'ğŸ¥‘', 'ğŸ…'],
            dinosaurs: ['ğŸ¦•', 'ğŸ¦–', 'ğŸ¦´', 'ğŸ¦', 'ğŸŠ', 'ğŸ¢', 'ğŸ¦', 'ğŸ¦˜', 'ğŸ‰', 'ğŸ¦¤', 'ğŸ²', 'ğŸ¦’', 'ğŸ', 'ğŸ¦', 'ğŸ¸', 'ğŸ¦‚', 'ğŸ•·ï¸', 'ğŸ¦—'],
            trucks: ['ğŸšš', 'ğŸš›', 'ğŸšœ', 'ğŸš—', 'ğŸš™', 'ğŸš•', 'ğŸš', 'ğŸš’', 'ğŸš“', 'ğŸš‘', 'ğŸï¸', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸ›µ', 'ğŸš²', 'ğŸ›´', 'ğŸš‚'],
            space: ['ğŸš€', 'ğŸ›¸', 'ğŸŒŸ', 'â­', 'ğŸŒ™', 'ğŸª', 'ğŸŒ', 'ğŸ‘½', 'ğŸ›°ï¸', 'â˜„ï¸', 'ğŸŒŒ', 'ğŸ”­', 'ğŸŒ ', 'ğŸŒ•', 'ğŸŒ', 'ğŸŒ', 'â˜€ï¸', 'âœ¨'],
            faces: ['ğŸ˜€', 'ğŸ¥°', 'ğŸ˜', 'ğŸ˜­', 'ğŸ˜¡', 'ğŸ¤¢', 'ğŸ˜±', 'ğŸ¥³', 'ğŸ¤¯', 'ğŸ˜´', 'ğŸ¤“', 'ğŸ¤—', 'ğŸ˜µ', 'ğŸ¤', 'ğŸ¥º', 'ğŸ¤ª', 'ğŸ˜‡', 'ğŸ¤¤']
        };

        const gridSizes = {
            '3x4': { rows: 4, cols: 3, pairs: 6 },
            '4x4': { rows: 4, cols: 4, pairs: 8 },
            '4x5': { rows: 5, cols: 4, pairs: 10 },
            '5x6': { rows: 6, cols: 5, pairs: 15 },
            '6x6': { rows: 6, cols: 6, pairs: 18 }
        };
        
        let cards = [];
        let flippedCards = [];
        let moves = 0;
        let totalPairs = 0;
        let canFlip = true;
        let gameMode = 'solo';
        let currentPlayer = 'human';
        let playerMatches = 0;
        let opponentMatches = 0;
        let computerMemory = {};
        let computerMemoryTurns = {};
        let turnNumber = 0;
        let difficulty = 'medium';
        let startTime = null;
        let timerInterval = null;
        let finalScoreText = '';

        // Online multiplayer state
        let onlineMode = false;
        let currentRoomCode = null;
        let playerId = null;
        let playerRole = null; // 'player1' or 'player2'
        let roomListener = null;
        let previouslyMatchedCards = [];
        
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9);
        }

        function generateRoomCode() {
            const adjectives = ['BLUE', 'RED', 'GREEN', 'GOLD', 'PINK', 'COOL', 'FAST', 'BOLD'];
            const nouns = ['TIGER', 'EAGLE', 'SHARK', 'WOLF', 'BEAR', 'LION', 'HAWK', 'DRAGON'];
            const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            return `${adj}-${noun}`;
        }

        window.handleModeChange = function() {
            const mode = document.getElementById('modeSelect').value;
            if (mode === 'vs-friend') {
                document.getElementById('roomModal').classList.add('show');
            } else {
                onlineMode = false;
                if (currentRoomCode && roomListener) {
                    roomListener();
                    currentRoomCode = null;
                }
                initGame();
            }
        };

        window.handleSettingsChange = function() {
            if (!onlineMode) {
                initGame();
            }
        };

        window.createRoom = async function() {
            playerId = generatePlayerId();
            currentRoomCode = generateRoomCode();
            playerRole = 'player1';

            const gridSize = document.getElementById('sizeSelect').value;
            const theme = document.getElementById('themeSelect').value;
            const symbols = themes[theme];
            const size = gridSizes[gridSize];
            
            const cardSymbols = [];
            for (let i = 0; i < size.pairs; i++) {
                cardSymbols.push(symbols[i], symbols[i]);
            }
            const shuffledCards = shuffle(cardSymbols);

            const roomData = {
                player1: playerId,
                player2: null,
                gridSize: gridSize,
                theme: theme,
                cards: shuffledCards,
                currentPlayer: 'player1',
                player1Score: 0,
                player2Score: 0,
                matchedCards: [],
                lastMove: null,
                gameStarted: false
            };

            await window.firebaseSet(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode), roomData);
            
            document.getElementById('roomModal').classList.remove('show');
            document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
            document.getElementById('waitingModal').classList.add('show');

            listenToRoom();
        };

        window.showJoinInput = function() {
            document.getElementById('joinInput').style.display = 'block';
        };

        window.hideJoinInput = function() {
            document.getElementById('joinInput').style.display = 'none';
            document.getElementById('roomCodeInput').value = '';
        };

        window.joinRoom = async function() {
            const code = document.getElementById('roomCodeInput').value.toUpperCase().trim();
            if (!code) return;

            const roomRef = window.firebaseRef(window.firebaseDb, 'rooms/' + code);
            const snapshot = await window.firebaseGet(roomRef);
            
            if (!snapshot.exists()) {
                alert('Room not found! Check the code and try again.');
                return;
            }

            const roomData = snapshot.val();
            if (roomData.player2) {
                alert('This room is already full!');
                return;
            }

            playerId = generatePlayerId();
            currentRoomCode = code;
            playerRole = 'player2';

            await window.firebaseUpdate(roomRef, {
                player2: playerId,
                gameStarted: true,
                currentPlayer: Math.random() < 0.5 ? 'player1' : 'player2'
            });

            document.getElementById('roomModal').classList.remove('show');
            document.getElementById('joinInput').style.display = 'none';
            document.getElementById('roomCodeInput').value = '';

            listenToRoom();
            initOnlineGame(roomData);
        };

        window.cancelRoom = function() {
            if (currentRoomCode) {
                window.firebaseRemove(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode));
            }
            currentRoomCode = null;
            document.getElementById('waitingModal').classList.remove('show');
            document.getElementById('modeSelect').value = 'solo';
            initGame();
        };

        window.copyRoomCode = function() {
            navigator.clipboard.writeText(currentRoomCode);
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'âœ“ Copied!';
            btn.classList.add('copied');
            setTimeout(() => {
                btn.textContent = originalText;
                btn.classList.remove('copied');
            }, 2000);
        };

        function listenToRoom() {
            const roomRef = window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode);
            roomListener = window.firebaseOnValue(roomRef, (snapshot) => {
                if (!snapshot.exists()) {
                    alert('The game room has been closed.');
                    currentRoomCode = null;
                    document.getElementById('waitingModal').classList.remove('show');
                    document.getElementById('modeSelect').value = 'solo';
                    initGame();
                    return;
                }

                const roomData = snapshot.val();
                
                if (playerRole === 'player1' && roomData.player2 && roomData.gameStarted) {
                    document.getElementById('waitingModal').classList.remove('show');
                    initOnlineGame(roomData);
                }

                if (roomData.gameStarted && onlineMode) {
                    updateGameFromRoom(roomData);
                }
            });
        }

        function initOnlineGame(roomData) {
            onlineMode = true;
            gameMode = 'vs-friend';
            previouslyMatchedCards = [];

            document.getElementById('sizeSelect').value = roomData.gridSize;
            document.getElementById('themeSelect').value = roomData.theme;

            const size = gridSizes[roomData.gridSize];
            totalPairs = size.pairs;
            cards = roomData.cards;

            currentPlayer = roomData.currentPlayer;
            playerMatches = roomData.player1Score || 0;
            opponentMatches = roomData.player2Score || 0;

            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            flippedCards = [];
            canFlip = true;

            gameBoard.style.gridTemplateColumns = `repeat(${size.cols}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${size.rows}, 1fr)`;

            const soloStats = document.getElementById('soloStats');
            const vsStats = document.getElementById('vsStats');
            soloStats.style.display = 'none';
            vsStats.style.display = '';
            document.getElementById('playerScore').textContent = playerRole === 'player1' ? roomData.player1Score : roomData.player2Score;
            document.getElementById('opponentScore').textContent = playerRole === 'player1' ? roomData.player2Score : roomData.player1Score;

            updateTurnIndicator();

            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                if (roomData.matchedCards && roomData.matchedCards.includes(index)) {
                    card.classList.add('matched');
                }
                
                card.innerHTML = `
                    <div class="card-face card-back">?</div>
                    <div class="card-face card-front">${symbol}</div>
                `;
                
                card.addEventListener('click', () => flipCardOnline(card));
                gameBoard.appendChild(card);
            });
        }

        function updateGameFromRoom(roomData) {
            if (!onlineMode) return;

            currentPlayer = roomData.currentPlayer;
            const myScore = playerRole === 'player1' ? roomData.player1Score : roomData.player2Score;
            const theirScore = playerRole === 'player1' ? roomData.player2Score : roomData.player1Score;
            
            document.getElementById('playerScore').textContent = myScore;
            document.getElementById('opponentScore').textContent = theirScore;

            playerMatches = myScore;
            opponentMatches = theirScore;

            updateTurnIndicator();

            if (roomData.matchedCards) {
                const currentMatched = new Set(roomData.matchedCards);
                const previousMatched = new Set(previouslyMatchedCards);
                
                // Find newly matched cards
                const newlyMatched = [...currentMatched].filter(x => !previousMatched.has(x));
                
                // Check if these are part of the current opponent move
                const isCurrentMove = roomData.lastMove && 
                                     roomData.lastMove.player !== playerId && 
                                     roomData.lastMove.matched;
                
                // Only animate newly matched cards if they're NOT the opponent's current move
                // (because lastMove animation will handle those)
                if (!isCurrentMove && newlyMatched.length > 0) {
                    newlyMatched.forEach(index => {
                        const card = document.querySelector(`[data-index="${index}"]`);
                        if (card && !card.classList.contains('matched')) {
                            card.classList.add('flipped');
                            setTimeout(() => {
                                card.classList.add('matched');
                                card.classList.remove('flipped');
                            }, 800);
                        }
                    });
                }
                
                // Update tracking
                previouslyMatchedCards = roomData.matchedCards;
            }
            
            if (roomData.lastMove && roomData.lastMove.player !== playerId) {
                const cardIndices = roomData.lastMove.cards;
                if (cardIndices && cardIndices.length === 2) {
                    setTimeout(() => {
                        const card1 = document.querySelector(`[data-index="${cardIndices[0]}"]`);
                        const card2 = document.querySelector(`[data-index="${cardIndices[1]}"]`);
                        if (card1 && card2) {
                            card1.classList.add('flipped');
                            setTimeout(() => {
                                card2.classList.add('flipped');
                                
                                setTimeout(() => {
                                    if (roomData.lastMove.matched) {
                                        // If it was a match, add the matched class to make them disappear
                                        card1.classList.add('matched');
                                        card2.classList.add('matched');
                                    } else {
                                        // If not a match, flip them back
                                        card1.classList.remove('flipped');
                                        card2.classList.remove('flipped');
                                    }
                                }, 1000);
                            }, 500);
                        }
                    }, 300);
                }
            }

            const totalMatches = roomData.player1Score + roomData.player2Score;
            if (totalMatches === totalPairs) {
                setTimeout(() => showOnlineWinMessage(roomData), 500);
            }
        }

        async function flipCardOnline(card) {
            if (!canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) {
                return;
            }

            const isMyTurn = (playerRole === 'player1' && currentPlayer === 'player1') || 
                            (playerRole === 'player2' && currentPlayer === 'player2');
            
            if (!isMyTurn) {
                return;
            }

            card.classList.add('flipped');
            flippedCards.push(card);

            if (flippedCards.length === 2) {
                canFlip = false;
                const card1 = flippedCards[0];
                const card2 = flippedCards[1];
                const symbol1 = card1.dataset.symbol;
                const symbol2 = card2.dataset.symbol;
                const index1 = parseInt(card1.dataset.index);
                const index2 = parseInt(card2.dataset.index);

                const roomRef = window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode);
                const snapshot = await window.firebaseGet(roomRef);
                const roomData = snapshot.val();

                if (symbol1 === symbol2) {
                    setTimeout(async () => {
                        const matchedCards = roomData.matchedCards || [];
                        matchedCards.push(index1, index2);

                        const scoreKey = playerRole === 'player1' ? 'player1Score' : 'player2Score';
                        const newScore = (roomData[scoreKey] || 0) + 1;

                        await window.firebaseUpdate(roomRef, {
                            [scoreKey]: newScore,
                            matchedCards: matchedCards,
                            lastMove: {
                                player: playerId,
                                cards: [index1, index2],
                                matched: true
                            }
                        });

                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        flippedCards = [];
                        canFlip = true;
                    }, 500);
                } else {
                    setTimeout(async () => {
                        await window.firebaseUpdate(roomRef, {
                            currentPlayer: playerRole === 'player1' ? 'player2' : 'player1',
                            lastMove: {
                                player: playerId,
                                cards: [index1, index2],
                                matched: false
                            }
                        });

                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                        flippedCards = [];
                        canFlip = true;
                    }, 1000);
                }
            }
        }

        function showOnlineWinMessage(roomData) {
            const myScore = playerRole === 'player1' ? roomData.player1Score : roomData.player2Score;
            const theirScore = playerRole === 'player1' ? roomData.player2Score : roomData.player1Score;
            
            const winTitle = document.getElementById('winTitle');
            const winContent = document.getElementById('winContent');
            const scoreTextEl = document.getElementById('scoreText');
            
            const gridSize = document.getElementById('sizeSelect').value;
            const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
            
            if (myScore > theirScore) {
                winTitle.textContent = 'ğŸ‰ You Win!';
            } else if (theirScore > myScore) {
                winTitle.textContent = 'ğŸ˜¢ You Lose!';
            } else {
                winTitle.textContent = 'ğŸ¤ Tie Game!';
            }
            
            winContent.innerHTML = `
                <p>Final Score:</p>
                <p>You: ${myScore}</p>
                <p>Opponent: ${theirScore}</p>
            `;
            
            finalScoreText = `Memory Game - VS Friend Online
Grid: ${gridSize}
Theme: ${theme}
Final Score:
  You: ${myScore}
  Opponent: ${theirScore}
Result: ${myScore > theirScore ? 'You Win!' : theirScore > myScore ? 'You Lose!' : 'Tie!'}`;
            
            scoreTextEl.textContent = finalScoreText;
            document.getElementById('winMessage').classList.add('show');

            if (currentRoomCode) {
                window.firebaseRemove(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode));
                currentRoomCode = null;
            }
        }

        function getCurrentTheme() {
            const select = document.getElementById('themeSelect');
            return themes[select.value];
        }

        function getCurrentGridSize() {
            const select = document.getElementById('sizeSelect');
            return gridSizes[select.value];
        }

        function getRandomTheme() {
            const themeKeys = Object.keys(themes);
            const randomIndex = Math.floor(Math.random() * themeKeys.length);
            return themeKeys[randomIndex];
        }

        function getRandomGridSize() {
            const sizeKeys = Object.keys(gridSizes);
            const randomIndex = Math.floor(Math.random() * sizeKeys.length);
            return sizeKeys[randomIndex];
        }

        function setRandomTheme() {
            const select = document.getElementById('themeSelect');
            select.value = getRandomTheme();
        }

        function setRandomGridSize() {
            const select = document.getElementById('sizeSelect');
            select.value = getRandomGridSize();
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function getElapsedTime() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
            const turnText = document.getElementById('turnText');
            
            if (gameMode === 'vs-friend') {
                indicator.style.display = 'inline-block';
                const isMyTurn = (playerRole === 'player1' && currentPlayer === 'player1') || 
                                (playerRole === 'player2' && currentPlayer === 'player2');
                turnText.textContent = isMyTurn ? 'Your Turn' : 'Opponent Turn';
            } else if (gameMode !== 'solo') {
                indicator.style.display = 'inline-block';
                turnText.textContent = currentPlayer === 'human' ? 'Your Turn' : 'Computer Turn';
            } else {
                indicator.style.display = 'none';
            }
        }

        window.initGame = function() {
            if (onlineMode) {
                if (currentRoomCode) {
                    window.firebaseRemove(window.firebaseRef(window.firebaseDb, 'rooms/' + currentRoomCode));
                    currentRoomCode = null;
                }
                onlineMode = false;
            }

            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';
            flippedCards = [];
            moves = 0;
            playerMatches = 0;
            opponentMatches = 0;
            computerMemory = {};
            computerMemoryTurns = {};
            turnNumber = 0;
            canFlip = true;
            
            stopTimer();
            
            const modeSelect = document.getElementById('modeSelect').value;
            
            if (modeSelect === 'solo') {
                gameMode = 'solo';
                difficulty = null;
            } else if (modeSelect === 'vs-friend') {
                return;
            } else {
                gameMode = 'vs';
                if (modeSelect === 'vs-easy') difficulty = 'easy';
                else if (modeSelect === 'vs-medium') difficulty = 'medium';
                else if (modeSelect === 'vs-hard') difficulty = 'hard';
            }
            
            const gridSize = getCurrentGridSize();
            const symbols = getCurrentTheme();
            totalPairs = gridSize.pairs;

            if (gameMode === 'vs') {
                currentPlayer = Math.random() < 0.5 ? 'human' : 'computer';
            } else {
                currentPlayer = 'human';
            }

            gameBoard.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`;
            gameBoard.style.gridTemplateRows = `repeat(${gridSize.rows}, 1fr)`;
            
            const soloStats = document.getElementById('soloStats');
            const vsStats = document.getElementById('vsStats');
            
            if (gameMode === 'solo') {
                soloStats.style.display = '';
                vsStats.style.display = 'none';
                document.getElementById('moves').textContent = '0';
                document.getElementById('timer').textContent = '0:00';
                startTimer();
            } else {
                soloStats.style.display = 'none';
                vsStats.style.display = '';
                document.getElementById('playerScore').textContent = '0';
                document.getElementById('opponentScore').textContent = '0';
            }
            
            updateTurnIndicator();
            document.getElementById('winMessage').classList.remove('show');

            const cardSymbols = [];
            for (let i = 0; i < gridSize.pairs; i++) {
                cardSymbols.push(symbols[i], symbols[i]);
            }

            cards = shuffle(cardSymbols);

            cards.forEach((symbol, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.symbol = symbol;
                card.dataset.index = index;
                
                card.innerHTML = `
                    <div class="card-face card-back">?</div>
                    <div class="card-face card-front">${symbol}</div>
                `;
                
                card.addEventListener('click', () => flipCard(card));
                gameBoard.appendChild(card);
            });

            if (gameMode === 'vs' && currentPlayer === 'computer') {
                setTimeout(computerTurn, 1000);
            }
        };

        function flipCard(card) {
            if (!canFlip || card.classList.contains('flipped') || card.classList.contains('matched')) {
                return;
            }

            if (gameMode === 'vs' && currentPlayer !== 'human') {
                return;
            }

            card.classList.add('flipped');
            flippedCards.push(card);

            if (gameMode === 'vs') {
                const index = card.dataset.index;
                const symbol = card.dataset.symbol;
                computerMemory[index] = symbol;
                computerMemoryTurns[index] = turnNumber;
            }

            if (flippedCards.length === 2) {
                canFlip = false;
                checkMatch();
            }
        }

        function checkMatch() {
            const [card1, card2] = flippedCards;
            const symbol1 = card1.dataset.symbol;
            const symbol2 = card2.dataset.symbol;

            if (symbol1 === symbol2) {
                setTimeout(() => {
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    
                    if (gameMode === 'solo') {
                        moves++;
                    } else {
                        if (currentPlayer === 'human') {
                            playerMatches++;
                            document.getElementById('playerScore').textContent = playerMatches;
                        } else {
                            opponentMatches++;
                            document.getElementById('opponentScore').textContent = opponentMatches;
                        }
                    }
                    
                    flippedCards = [];
                    canFlip = true;

                    const totalMatches = gameMode === 'solo' ? moves : (playerMatches + opponentMatches);
                    if (totalMatches === totalPairs) {
                        setTimeout(() => showWinMessage(), 500);
                    } else if (gameMode === 'vs') {
                        if (currentPlayer === 'computer') {
                            setTimeout(computerTurn, 1000);
                        }
                    }
                }, 500);
            } else {
                turnNumber++;
                
                if (gameMode === 'solo') {
                    moves++;
                    document.getElementById('moves').textContent = moves;
                }
                
                setTimeout(() => {
                    card1.classList.remove('flipped');
                    card2.classList.remove('flipped');
                    flippedCards = [];
                    canFlip = true;

                    if (gameMode === 'vs') {
                        currentPlayer = currentPlayer === 'human' ? 'computer' : 'human';
                        updateTurnIndicator();
                        
                        if (currentPlayer === 'computer') {
                            setTimeout(computerTurn, 1000);
                        }
                    }
                }, 1000);
            }
        }

        function computerTurn() {
            if (currentPlayer !== 'computer' || !canFlip) return;

            if (difficulty === 'hard') {
                computerTurnHard();
            } else if (difficulty === 'medium') {
                computerTurnMedium();
            } else {
                computerTurnEasy();
            }
        }

        function getComputerMemory() {
            if (difficulty === 'easy') {
                const recentMemory = {};
                for (const [index, symbol] of Object.entries(computerMemory)) {
                    if (turnNumber - computerMemoryTurns[index] <= 4) {
                        recentMemory[index] = symbol;
                    }
                }
                return recentMemory;
            } else {
                return computerMemory;
            }
        }

        function computerTurnMedium() {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            const knownPairs = findKnownPairWithMemory(memory);
            
            let card1, card2;
            
            if (knownPairs) {
                [card1, card2] = knownPairs;
            } else {
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                if (unseenCards.length >= 2) {
                    card1 = unseenCards[0];
                    card2 = unseenCards[1];
                } else if (unseenCards.length === 1) {
                    card1 = unseenCards[0];
                    const otherCards = Array.from(allCards).filter(c => c !== card1);
                    card2 = otherCards[Math.floor(Math.random() * otherCards.length)];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                    const remaining = cardsArray.filter(c => c !== card1);
                    card2 = remaining[Math.floor(Math.random() * remaining.length)];
                }
            }

            setTimeout(() => {
                card1.classList.add('flipped');
                flippedCards.push(card1);
                computerMemory[card1.dataset.index] = card1.dataset.symbol;
                computerMemoryTurns[card1.dataset.index] = turnNumber;

                setTimeout(() => {
                    card2.classList.add('flipped');
                    flippedCards.push(card2);
                    computerMemory[card2.dataset.index] = card2.dataset.symbol;
                    computerMemoryTurns[card2.dataset.index] = turnNumber;
                    
                    canFlip = false;
                    checkMatch();
                }, 600);
            }, 400);
        }

        function computerTurnHard() {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            const knownPairs = findKnownPairWithMemory(memory);
            
            if (knownPairs) {
                const [card1, card2] = knownPairs;
                
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    computerMemory[card1.dataset.index] = card1.dataset.symbol;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            } else {
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                let card1;
                if (unseenCards.length > 0) {
                    card1 = unseenCards[0];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                }

                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    const symbol1 = card1.dataset.symbol;
                    computerMemory[card1.dataset.index] = symbol1;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    let card2 = null;
                    const updatedMemory = getComputerMemory();
                    
                    for (const card of allCards) {
                        if (card === card1 || card.classList.contains('matched')) continue;
                        const idx = card.dataset.index;
                        if (updatedMemory[idx] === symbol1) {
                            card2 = card;
                            break;
                        }
                    }

                    if (!card2) {
                        const remainingUnseen = Array.from(allCards).filter(c => 
                            c !== card1 && !updatedMemory[c.dataset.index]
                        );
                        
                        if (remainingUnseen.length > 0) {
                            card2 = remainingUnseen[0];
                        } else {
                            const remaining = Array.from(allCards).filter(c => c !== card1);
                            card2 = remaining[Math.floor(Math.random() * remaining.length)];
                        }
                    }

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            }
        }

        function computerTurnEasy() {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const memory = getComputerMemory();
            
            const knownPairs = findKnownPairWithMemory(memory);
            
            if (knownPairs) {
                const [card1, card2] = knownPairs;
                
                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    computerMemory[card1.dataset.index] = card1.dataset.symbol;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            } else {
                const unseenCards = Array.from(allCards).filter(c => !memory[c.dataset.index]);
                
                let card1;
                if (unseenCards.length > 0) {
                    card1 = unseenCards[0];
                } else {
                    const cardsArray = Array.from(allCards);
                    card1 = cardsArray[Math.floor(Math.random() * cardsArray.length)];
                }

                setTimeout(() => {
                    card1.classList.add('flipped');
                    flippedCards.push(card1);
                    const symbol1 = card1.dataset.symbol;
                    computerMemory[card1.dataset.index] = symbol1;
                    computerMemoryTurns[card1.dataset.index] = turnNumber;

                    let card2 = null;
                    const updatedMemory = getComputerMemory();
                    
                    for (const card of allCards) {
                        if (card === card1 || card.classList.contains('matched')) continue;
                        const idx = card.dataset.index;
                        if (updatedMemory[idx] === symbol1) {
                            card2 = card;
                            break;
                        }
                    }

                    if (!card2) {
                        const remainingUnseen = Array.from(allCards).filter(c => 
                            c !== card1 && !updatedMemory[c.dataset.index]
                        );
                        
                        if (remainingUnseen.length > 0) {
                            card2 = remainingUnseen[0];
                        } else {
                            const remaining = Array.from(allCards).filter(c => c !== card1);
                            card2 = remaining[Math.floor(Math.random() * remaining.length)];
                        }
                    }

                    setTimeout(() => {
                        card2.classList.add('flipped');
                        flippedCards.push(card2);
                        computerMemory[card2.dataset.index] = card2.dataset.symbol;
                        computerMemoryTurns[card2.dataset.index] = turnNumber;
                        
                        canFlip = false;
                        checkMatch();
                    }, 600);
                }, 400);
            }
        }

        function findKnownPairWithMemory(memory) {
            const allCards = document.querySelectorAll('.card:not(.matched)');
            const symbolLocations = {};

            for (const card of allCards) {
                const index = card.dataset.index;
                if (memory[index] !== undefined) {
                    const symbol = memory[index];
                    if (!symbolLocations[symbol]) {
                        symbolLocations[symbol] = [];
                    }
                    symbolLocations[symbol].push(card);
                }
            }

            for (const symbol in symbolLocations) {
                if (symbolLocations[symbol].length >= 2) {
                    return [symbolLocations[symbol][0], symbolLocations[symbol][1]];
                }
            }

            return null;
        }

        function showWinMessage() {
            stopTimer();
            
            const winTitle = document.getElementById('winTitle');
            const winContent = document.getElementById('winContent');
            const scoreTextEl = document.getElementById('scoreText');
            
            if (gameMode === 'solo') {
                const elapsedTime = getElapsedTime();
                const gridSize = document.getElementById('sizeSelect').value;
                const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
                
                winTitle.textContent = 'ğŸ‰ Congratulations!';
                winContent.innerHTML = `
                    <p>You completed the game!</p>
                    <p>Time: ${elapsedTime}</p>
                    <p>Moves: ${moves}</p>
                `;
                
                finalScoreText = `Memory Game - Solo Mode
Grid: ${gridSize}
Theme: ${theme}
Time: ${elapsedTime}
Moves: ${moves}`;
            } else {
                const gridSize = document.getElementById('sizeSelect').value;
                const theme = document.getElementById('themeSelect').options[document.getElementById('themeSelect').selectedIndex].text;
                const difficultyText = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                
                if (playerMatches > opponentMatches) {
                    winTitle.textContent = 'ğŸ‰ You Win!';
                } else if (opponentMatches > playerMatches) {
                    winTitle.textContent = 'ğŸ¤– Computer Wins!';
                } else {
                    winTitle.textContent = 'ğŸ¤ Tie Game!';
                }
                
                winContent.innerHTML = `
                    <p>Final Score:</p>
                    <p>You: ${playerMatches}</p>
                    <p>Computer: ${opponentMatches}</p>
                `;
                
                finalScoreText = `Memory Game - VS ${difficultyText} Computer
Grid: ${gridSize}
Theme: ${theme}
Final Score:
  You: ${playerMatches}
  Computer: ${opponentMatches}
Result: ${playerMatches > opponentMatches ? 'You Win!' : opponentMatches > playerMatches ? 'Computer Wins!' : 'Tie!'}`;
            }
            
            scoreTextEl.textContent = finalScoreText;
            document.getElementById('winMessage').classList.add('show');
        }

        window.copyScore = function() {
            navigator.clipboard.writeText(finalScoreText).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalText = btn.textContent;
                btn.textContent = 'âœ“ Copied!';
                btn.classList.add('copied');
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy to clipboard');
            });
        };

        setRandomTheme();
        setRandomGridSize();
        initGame();
    </script>
</body>
</html>